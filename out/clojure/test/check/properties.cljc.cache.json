["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check.properties","~:imports",null,"~:requires",["^ ","~$gen","~$clojure.test.check.generators","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$apply-gen",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","~:line",13,"~:column",8,"~:end-line",13,"~:end-column",17,"~:private",true,"~:arglists",["~#list",["~$quote",["^H",[["~$function"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/apply-gen","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^E",17,"~:method-params",["^H",[["^J"]]],"~:protocol-impl",null,"~:arglists-meta",["^H",[null,null]],"^C",1,"~:variadic?",false,"^B",13,"~:ret-tag","^J","^D",13,"~:max-fixed-arity",1,"~:fn-var",true,"^G",["^H",["^I",["^H",[["^J"]]]]]],"~$for-all*",["^ ","^?",null,"^@",["^ ","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^B",23,"^C",7,"^D",23,"^E",15,"^G",["^H",["^I",["^H",[["~$args","^J"]]]]],"~:doc","Creates a property (properties are also generators). A property\n  is a generator that generates the result of applying the function\n  under test with the realized arguments. Once realized, the arguments\n  will be applied to `function` with `apply`.\n\n  Example:\n\n  (for-all* [gen/int gen/int] (fn [a b] (>= (+ a b) a)))\n  "],"^5","~$clojure.test.check.properties/for-all*","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^E",15,"^L",["^H",[["^T","^J"]]],"^M",null,"^N",["^H",[null,null]],"^C",1,"^O",false,"^B",23,"^P","~$clojure.test.check.generators/Generator","^D",23,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^T","^J"]]]]],"^U","Creates a property (properties are also generators). A property\n  is a generator that generates the result of applying the function\n  under test with the realized arguments. Once realized, the arguments\n  will be applied to `function` with `apply`.\n\n  Example:\n\n  (for-all* [gen/int gen/int] (fn [a b] (>= (+ a b) a)))\n  "],"~$binding-vars",["^ ","^?",null,"^@",["^ ","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^B",38,"^C",8,"^D",38,"^E",20,"^F",true,"^G",["^H",["^I",["^H",[["~$bindings"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/binding-vars","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^E",20,"^L",["^H",[["^Y"]]],"^M",null,"^N",["^H",[null,null]],"^C",1,"^O",false,"^B",38,"^P","~$cljs.core/LazySeq","^D",38,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^Y"]]]]]],"~$binding-gens",["^ ","^?",null,"^@",["^ ","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^B",42,"^C",8,"^D",42,"^E",20,"^F",true,"^G",["^H",["^I",["^H",[["^Y"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/binding-gens","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^E",20,"^L",["^H",[["^Y"]]],"^M",null,"^N",["^H",[null,null]],"^C",1,"^O",false,"^B",42,"^P","^[","^D",42,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^Y"]]]]]],"~$for-all",["^ ","^?",null,"^@",["^ ","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^B",46,"^C",11,"^D",46,"^E",18,"~:macro",true,"^G",["^H",["^I",["^H",[["^Y","~$&","~$body"]]]]],"^U","Macro sugar for `for-all*`. `for-all` lets you name the parameter\n  and use them in expression, without wrapping them in a lambda. Like\n  `for-all*`, it returns a property.\n\n  Examples\n\n  (for-all [a gen/int\n            b gen/int]\n    (>= (+ a b) a))\n  ","~:top-fn",["^ ","^O",true,"~:fixed-arity",1,"^Q",1,"^L",["^H",[["^H",["^Y","^14"]]]],"^G",["^H",[["^Y","~$&","^14"]]],"^N",["^H",[null]]]],"^5","~$clojure.test.check.properties/for-all","^A","/home/uer/.cljs/.aot_cache/1.10.773/B9EE154/clojure/test/check/properties.cljc","^E",18,"^15",["^ ","^O",true,"^16",1,"^Q",1,"^L",["^H",[["^H",["^Y","^14"]]]],"^G",["^H",[["^Y","~$&","^14"]]],"^N",["^H",[null]]],"^L",["^H",[["^H",["^Y","^14"]]]],"^M",null,"^16",1,"^N",["^H",[null]],"^C",1,"^O",true,"~:methods",[["^ ","^16",1,"^O",true,"~:tag",["^4",["~$seq","~$cljs.core/IList"]]]],"^B",46,"^13",true,"^P","~$any","^D",46,"^Q",1,"^R",false,"^G",["^H",[["^Y","~$&","^14"]]],"^U","Macro sugar for `for-all*`. `for-all` lets you name the parameter\n  and use them in expression, without wrapping them in a lambda. Like\n  `for-all*`, it returns a property.\n\n  Examples\n\n  (for-all [a gen/int\n            b gen/int]\n    (>= (+ a b) a))\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","^V","~:function","~:result","~$cljs.core/fn"]],"~:order",["^1C","^1B","^1A","^V","^1D"]],"^U",null]