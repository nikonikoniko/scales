["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$gen","~$clojure.test.check.generators","^:","^:","~$ct","~$clojure.test.check.clojure-test","^<","^<","~$random","~$clojure.test.check.random","^>","^>","~$rose","~$clojure.test.check.rose-tree","^@","^@","~$clojure.test.check.impl","^A"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$exception-like?","^A","~$get-current-time-millis","^A"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","~:line",79,"~:column",8,"~:end-line",79,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^Q",[["~$rose-tree"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"^O",true,"^5","~$clojure.test.check/shrink-loop","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",19,"~:method-params",["^Q",[["^S"]]],"~:protocol-impl",null,"~:arglists-meta",["^Q",[null,null]],"^L",1,"~:variadic?",false,"^K",79,"~:ret-tag","~$cljs.core/IMap","^M",79,"~:max-fixed-arity",1,"~:fn-var",true,"^P",["^Q",["^R",["^Q",[["^S"]]]]],"^T","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"~$failure",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",112,"^L",8,"^M",112,"^N",15,"^O",true,"^P",["^Q",["^R",["^Q",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed"]]]]]],"^O",true,"^5","~$clojure.test.check/failure","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",15,"^V",["^Q",[["^13","^14","^15","^16","^17"]]],"^W",null,"^X",["^Q",[null,null]],"^L",1,"^Y",false,"^K",112,"^Z","^[","^M",112,"^10",5,"^11",true,"^P",["^Q",["^R",["^Q",[["^13","^14","^15","^16","^17"]]]]]],"~$make-rng",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",20,"^L",8,"^M",20,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^17"]]]]]],"^O",true,"^5","~$clojure.test.check/make-rng","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",16,"^V",["^Q",[["^17"]]],"^W",null,"^X",["^Q",[null,null]],"^L",1,"^Y",false,"^K",20,"^Z","~$cljs.core/IVector","^M",20,"^10",1,"^11",true,"^P",["^Q",["^R",["^Q",[["^17"]]]]]],"~$complete",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",27,"^L",8,"^M",27,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^13","~$num-trials","^17"]]]]]],"^O",true,"^5","~$clojure.test.check/complete","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",16,"^V",["^Q",[["^13","^1=","^17"]]],"^W",null,"^X",["^Q",[null,null]],"^L",1,"^Y",false,"^K",27,"^Z","^[","^M",27,"^10",3,"^11",true,"^P",["^Q",["^R",["^Q",[["^13","^1=","^17"]]]]]],"~$not-falsey-or-exception?",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",32,"^L",8,"^M",32,"^N",32,"^O",true,"^P",["^Q",["^R",["^Q",[["~$value"]]]]],"^T","True if the value is not falsy or an exception"],"^O",true,"^5","~$clojure.test.check/not-falsey-or-exception?","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",32,"^V",["^Q",[["^1@"]]],"^W",null,"^X",["^Q",[null,null]],"^L",1,"^Y",false,"^K",32,"^Z",["^4",[null,"~$boolean"]],"^M",32,"^10",1,"^11",true,"^P",["^Q",["^R",["^Q",[["^1@"]]]]],"^T","True if the value is not falsy or an exception"],"~$quick-check",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",37,"^L",7,"^M",37,"^N",18,"^P",["^Q",["^R",["^Q",[["~$num-tests","^13","~$&",["^ ","~:keys",["^17","~$max-size"],"~:or",["^ ","^1F",200]]]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  ","~:top-fn",["^ ","^Y",true,"~:fixed-arity",2,"^10",2,"^V",[["^Q",["^1D","^13",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^P",["^Q",[["^1D","^13","~$&",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^X",["^Q",[null]]]],"^5","~$clojure.test.check/quick-check","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",18,"^1H",["^ ","^Y",true,"^1I",2,"^10",2,"^V",[["^Q",["^1D","^13",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^P",["^Q",[["^1D","^13","~$&",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^X",["^Q",[null]]],"^V",[["^Q",["^1D","^13",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^W",null,"^1I",2,"^X",["^Q",[null]],"^L",1,"^Y",true,"~:methods",[["^ ","^1I",2,"^Y",true,"~:tag",["^4",["~$any","^["]]]],"^K",37,"^Z","^1M","^M",37,"^10",2,"^11",true,"^P",["^Q",[["^1D","^13","~$&",["^ ","^1E",["^17","^1F"],"^1G",["^ ","^1F",200]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  "],"~$smallest-shrink",["^ ","^H",null,"^I",["^ ","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^K",72,"^L",8,"^M",72,"^N",23,"^O",true,"^P",["^Q",["^R",["^Q",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^O",true,"^5","~$clojure.test.check/smallest-shrink","^J","/home/uer/.cljs/.aot_cache/1.10.773/F1DC3EB/clojure/test/check.cljc","^N",23,"^V",["^Q",[["^1O","^1P","^1Q"]]],"^W",null,"^X",["^Q",[null,null]],"^L",1,"^Y",false,"^K",72,"^Z","^[","^M",72,"^10",3,"^11",true,"^P",["^Q",["^R",["^Q",[["^1O","^1P","^1Q"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~:shrunk","~:total-nodes-visited","~:num-tests","~:max-size","~:seed","~:fail","~:result","~:smallest","~:failing-size","~:depth"]],"~:order",["^22","^1Z","^20","^1[","^1W","^1Y","^25","^23","^24","^21","^1X"]],"^T",null]